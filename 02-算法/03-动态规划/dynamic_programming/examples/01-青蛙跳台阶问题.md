leetcode 已将青蛙跳台阶问题换成了 [LCR 127. 跳跃训练](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/description/)

### 为何使用dp方法求解？

**1. 可以将问题拆分成多个子问题，并且这些子问题可以使用同一个模板求解**

由于每次只能选择跳一阶或两阶台阶，因此想要到达第 n 阶台阶，只有两种可能分别是

1. 从 n-1 跳 1 节台阶到达 n
2. 从 n-2 跳 2 节台阶到达 n

因此: (到达第 n 阶的方法数) = （到达 n-1 阶的方法数) + (到达第 n-2 阶的方法数)

那就要分别求解 （到达 n-1 阶的方法数) 和 (到达第 n-2 阶的方法数)

而它们的求解过程，都可以抽象为 (到达第 n 阶的方法数) 的求解过程。

**2. 具有很多重叠子问题**

求 (到达第 n 阶的方法数) 总是要依赖于抵达前两个台阶的方法数结果。

因此求解该题，需要优先把重叠子问题的结果求出并收集起来，这样在进行下一次计算的时候，直接拿来用即可，不需要再次计算。

如何收集重叠子问题，才能保证当前求解过程所依赖的解已经被求出了？

​	具体情况具体分析，而对于该例题来说，我们需要优先从最小的台阶数进行求解。因为求解 (到达第 n 阶的方法数) 总是依赖于抵达之前较小台阶数的结果。

### 求解过程

dp

```
  var trainWays = function (num) {
    if (num == 0) return 1
    let dp = Array.from({ length: num }).fill(0)
    dp[0] = 1
    dp[1] = 2
    for (let i = 2; i < num; i++) {
      dp[i] = (dp[i - 1] + dp[i - 2]) % (1e9 + 7)
    }
    return dp[num - 1]
  }
```

转化为斐波那契数列问题

​	由于该例题不需要将每一阶台阶的结果罗列出来，所以没必要创建一个完整的 dp 数组进行存储，求当前台阶的结果，只需要依赖前两次的结果进行计算。

```
  var trainWays = function (num) {
    let arr = [1, 2]
    if (num <= 2) return arr?.[num - 1] || 1
    let res
    for (let i = 2; i < num; i++) {
      res = (arr[0] + arr[1]) % (1e9 + 7)
      arr[0] = arr[1]
      arr[1] = res
    }
    return res
  }
```

