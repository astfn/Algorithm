## 题目

[原题](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnq4km/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2：

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```


提示：

* 1 <= nums.length <= 100
* 0 <= nums[i] <= 400

## 代码实现

### 错误代码

根据原题中的两个示例，你可能会写出以下代码:

* 不能同时盗窃紧挨着的房屋
* 每次都间隔一家进行盗窃即可
* 双层 for 循环进行遍历，保留最大值

```
var rob = function(nums) {
  let res = nums[0];
  for(let i=0;i<nums.length;i++){
      let sum = nums[i];
      for(let j=i+2;j<nums.length;j+=2){
          sum+=nums[j]
      }
      res = Math.max(res,sum)
  }
  return res;
}
```

但很遗憾，这种方式不能通过一些用例，因为每次都间隔一家进行盗窃，可能并不是最大值，例如用例：

```
[2,1,1,2]
```

按照上述代码，只能得出结果为 3 （`nums[0]+nums[2] 或 nums[1]+nums[3]`），但很显然，我们可以盗窃第一家与最后一家，得到最大值 4 .

正确求解，可以使用动态规划解决👇

### 动态规划

**动规五部曲：**

1. 设计 `dp`，理解下标含义（状态转移）
2. 找到递推公式
3. 合理初始化 `dp`（为了让 dp 完全符合递推公式）
4. 确定遍历顺序（与递推公式有关。保证每次求解时，所遇到的依赖项都已被计算）
5. 打印 dp , debug

**本题思路：**

*设计 dp：*

根据题意可知，不能同时盗窃紧挨着的房屋，因此也就代表：

* 第 `i` 家如果已经盗窃，则第 `i+1` 家必然不能盗窃。
* 反之，第 `i+1` 家可以盗窃，也可以选择不盗窃。

因此每一家都有两种可能的状态：被盗窃、未被盗窃

因此 `dp` 可以初始化为一个二维数组，第二维度数组用于存储：当前家庭处于不同状态下，所对应的盗窃最大值

* 例如：`dp[0][0]` 代表第一家未被盗窃时的最大值，`dp[0][1]` 为第一家被盗窃时的最大值

*递推公式：*

* `dp[i][0] = max(dp[i-1][0],dp[i-1][1])`

  当前家庭未被盗窃，则应该沿用之前偷盗的结果：前一家可能被盗、也可能没有被盗，求最大值。

* `dp[i][1] = dp[i-1][0] + nums[i]`

  当前家庭被盗窃，则：前一家必然没被盗窃，让上一家没被盗窃的结果 + 当前家的价值

*遍历方式：*

* 由递推公式可知，需要自左向右遍历
* 为了保证后续正常求解，需要初始化 `dp` 第一项
* 最后返回两种情况之间的最大值即可

```
var rob = function(nums) {
  let dp = Array.from({length:nums.length}).map(_=>new Array(2).fill(0));
  dp[0][0] = 0;
  dp[0][1] = nums[0];

  for(let i =1;i<nums.length;i++){
    dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]);
    dp[i][1] = dp[i-1][0] + nums[i];
  }
  return Math.max(dp[nums.length-1][0],dp[nums.length-1][1]);
}
```

