## 概要

回溯与递归是紧密联系的，只要有递归就存在回溯。

#### 关于效率

前面我们说到，回溯是伴随递归产生的，而递归是**暴力的**。

因为递归的本质是穷举，通过不断地递归，穷举所有可能结果，直至符合要求。

你可能会有疑问：既然是暴力算法，为何还要采用它？

* 因为有些问题，能够通过暴力搜索出来就已经很不错了。

实际上，我们还可以通过 **剪枝操作 **来优化回溯的过程。

#### 理解回溯

**回溯法解决的问题都可以抽象为树形结构**

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，而递归的深度，也就构成了树的深度**。

## 核心

回溯三部曲：

1. 确定 `backtracking` 的参数
   * 也可在编写逻辑的过程中逐步确定
2. ⭐确定终止条件
   * 收集结果，并 return
3. `for` 循环横向遍历各节点，并在其中编写单次搜索逻辑
   * 处理当前节点
   * 递归，进行纵向遍历
   * 回溯操作

进阶操作：剪枝优化

回溯三部曲伪代码：

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

