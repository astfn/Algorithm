## 题目

[原题](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/)

给定一个字符串，找到它的**第一个不重复的字符**，并返回它的索引。如果不存在，则返回 -1。

 

示例：

```
s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
```



## 代码实现

### 方案一

* 循环遍历每一个元素
* 从原数组 `filter` 出与之相等的元素
* 判断所返回的 Array 的长度，如果等于 1，则直接 return 当前 index
* 最后若没找到，return -1

>但是该方案每次都需要进行filter，性能不是很好，**leetcode 超时执行**😣

```
export default function firstUniqChar(s) {
  const toArray = s.split("");
  for (const [index, item] of Object.entries(toArray)) {
    const size = toArray.filter((v) => v === item).length;
    if (size === 1) {
      return index;
    }
  }
  return -1;
}
```

### 方案二

* 判断 `indexOf(item)===lastIndexOf(item)`
* 该方案很精妙：如果自前向后找、自后向前找。所返回的 `index` 相同，很显然该元素只出现了一次

```
export default function firstUniqChar(s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
}
```

### 方案三

* 双层 `for` 循环，让每一个元素都与 String 的其它元素进行比较。
* 定义一个 `flag` 判断当前元素是否重复出现

注意点：

* 避免与自身比较，否则一定会出现重复项
* 特殊处理 `str.length===1` 的情况，此时直接返回 `0`
  * 若不特殊处理，后续又不与自身进行比较，就会返回 `-1`

```
export default function firstUniqChar(s) {
  if (s.length === 1) return 0;
  for (let i = 0; i < s.length; i++) {
    let flag = true;
    for (let j = 0; j < s.length; j++) {
      //不与自身比较，会影响结果
      if (j == i) continue;  
      if (s[i] !== s[j]) {
        flag = false;
      }
      if (s[i] === s[j]) {
        flag = true;
        break;
      }
    }
    if (!flag) {
      return i;
    }
  }
  return -1;
}
```

